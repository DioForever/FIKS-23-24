using System;
using System.Collections.Generic;

class Graph
{
    private Dictionary<string, List<string>> graph;

    public Graph()
    {
        graph = new Dictionary<string, List<string>>();
    }

    public void AddEdge(string u, string v)
    {
        if (!graph.ContainsKey(u))
        {
            graph[u] = new List<string>();
        }
        graph[u].Add(v);
    }

    public List<Path> BFSAllShortestPaths(string start, string end, Dictionary<(string, string), (int[], string)> edges)
    {
        Queue<Tuple<string, List<string>>> queue = new Queue<Tuple<string, List<string>>>();
        queue.Enqueue(new Tuple<string, List<string>>(start, new List<string> { start }));

        List<Path> shortestPaths = new List<Path>();
        int shortestLength = int.MaxValue;

        while (queue.Count > 0)
        {
            var current = queue.Dequeue();
            string currentNode = current.Item1;
            List<string> path = current.Item2;

            // System.Console.WriteLine($"Visited {currentNode}");
            if (currentNode == end)
            {
                int currentLength = path.Count;

                if (currentLength < shortestLength)
                {
                    shortestPaths.Clear();
                    shortestLength = currentLength;
                    // If the Temperature is 0, there is no better path we need
                    System.Console.WriteLine($"Path {string.Join(", ", path)}");
                    var pathProps = GetPropOfPath(path, edges);
                    bool reachedDes = false;
                    if (path.Contains(end)) reachedDes = true;
                    Path pathObj = new Path(pathProps.visitedIdentificators, pathProps.temperature, reachedDes, pathProps.options);
                    shortestPaths.Add(pathObj);
                    if (pathObj.temperature == 0) return shortestPaths;
                }
                else if (currentLength == shortestLength)
                {
                    bool reachedDes = false;
                    if (path.Contains(end)) reachedDes = true;
                    Path pathObj = new Path(path, 0, reachedDes);
                    shortestPaths.Add(pathObj);
                }
            }
            // System.Console.WriteLine($"Not Last {currentNode}");

            if (graph.ContainsKey(currentNode))
            {
                // System.Console.WriteLine($"ey ");
                foreach (var neighbor in graph[currentNode])
                {
                    // System.Console.WriteLine($"tried {neighbor}");
                    if (!path.Contains(neighbor) && graph.ContainsKey(neighbor))
                    {
                        // System.Console.WriteLine($"Not repeating {neighbor}");
                        List<string> newPath = new List<string>(path);
                        newPath.Add(neighbor);
                        queue.Enqueue(new Tuple<string, List<string>>(neighbor, newPath));
                    }
                }
                // System.Console.WriteLine($"End");
            }
        }

        foreach (var path in shortestPaths)
        {

        }
        return shortestPaths;
    }
    /// <summary>
    ///     Function takes visited nodes, creates the correct format to be returned and counts its Temperature, even finds optional paths in case we need smaller Temperature.
    /// </summary>
    /// <param name="visited">List of visited nodes</param>
    /// <param name="edges">Dictionary storing edges with key - startingNode,endingNode, and value - possible values, possible indentificators  </param>
    static (List<string> visitedIdentificators, int temperature, Dictionary<string, string> options) GetPropOfPath(List<string> visited, Dictionary<(string, string), (int[], string)> edges)
    {
        List<string> visitedIdentificators = new List<string>();
        Dictionary<string, string> options = new Dictionary<string, string>();
        int temperature = 0;
        for (int i = 1; i < visited.Count; i++)
        {
            (int[] value, string identificator) edge = edges[(visited[i - 1], visited[i])];
            System.Console.WriteLine(string.Join(",", edge.value) + " " + edge.identificator);
            if (edge.value.Length == 1)
            {
                int value = edge.value[0];
                string identificator = edge.identificator.ToCharArray()[0].ToString();

                visitedIdentificators.Add(identificator);
                temperature += value;
            }
            else
            {
                // If there are two same choices, we disregard it as an option
                if (edge.value[0] == edge.value[1]) continue;

                // Now we use options, but we add the positive one of them
                int index = 0;
                int indexOpt = 1;
                if (edge.value[1] == 1) { index = 1; indexOpt = 0; }
                string chosenIdentificator = edge.identificator[index].ToString();

                temperature += edge.value[index];
                visitedIdentificators.Add(chosenIdentificator);


                string optionalIdentificator = edge.identificator[indexOpt].ToString();
                options.Add(chosenIdentificator, optionalIdentificator);
            }
        }
        return (visitedIdentificators, temperature, options);
    }

    static Path correctPath(Path path)
    {
        if (path.options.Count == 0) return path;
        return path;
    }
}

class Path
{
    public List<string> visited;
    public int temperature;
    public Dictionary<string, string> options;
    public bool reachedDes;

    public Path(List<string> visited, int temperature, bool reachedDes, Dictionary<string, string> options = null)
    {
        this.visited = visited;
        this.temperature = temperature;
        this.options = options ?? new Dictionary<string, string>();
        this.reachedDes = reachedDes;
    }
}





class Program
{
    static void Main()
    {
        Graph graph = new Graph();
        Dictionary<(string, string), (int[] temps, string idents)> edges = new Dictionary<(string, string), (int[], string)>();


        // int[] edge0Temperature = new int[1] { 1 };
        // string edge0Identificator = "0";
        // graph.AddEdge("0", "1");
        // edges.Add(("0", "1"), (edge0Temperature, edge0Identificator));
        // int[] edge1Temperature = new int[1] { -1 };
        // string edge1Identificator = "1";
        // graph.AddEdge("0", "2");
        // edges.Add(("0", "2"), (edge1Temperature, edge1Identificator));
        // int[] edge2Temperature = new int[1] { -1 };
        // string edge2Identificator = "2";
        // graph.AddEdge("1", "3");
        // edges.Add(("1", "3"), (edge2Temperature, edge2Identificator));
        // int[] edge3Temperature = new int[1] { 1 };
        // string edge3Identificator = "3";
        // edges.Add(("2", "3"), (edge3Temperature, edge3Identificator));
        // graph.AddEdge("2", "3");


        // graph.AddEdge("0", "1");
        // graph.AddEdge("1", "2");
        // graph.AddEdge("2", "3");
        // graph.AddEdge("3", "4");
        // graph.AddEdge("0", "1");
        // int[] edge0Temperature = new int[1] { 1 };
        // string edge0Identificator = "0";
        // edges.Add(("0", "1"), (edge0Temperature, edge0Identificator));

        // int[] edge1Temperature = new int[2] { -1, 1 };
        // string edge1Identificator = "12";
        // graph.AddEdge("1", "2");
        // edges.Add(("1", "2"), (edge1Temperature, edge1Identificator));

        // int[] edge2Temperature = new int[1] { -1 };
        // string edge2Identificator = "3";
        // graph.AddEdge("2", "3");
        // edges.Add(("2", "3"), (edge2Temperature, edge2Identificator));

        // int[] edge3Temperature = new int[1] { -1 };
        // string edge3Identificator = "4";
        // edges.Add(("3", "4"), (edge3Temperature, edge3Identificator));
        // graph.AddEdge("3", "4");

        // string startNode = "0";
        // string endNode = "4";
        string[] input_unparsed = File.ReadAllLines("input.txt");
        int t = int.Parse(input_unparsed[0]); // Number of tasks
        int linePointer = 1;
        for (int task = 0; task < t; task++)
        {
            System.Console.WriteLine($"START {task + 1}/{t}");

            string[] line_nm = input_unparsed[linePointer].Split(" ");
            linePointer++;

            int n = int.Parse(line_nm[0]);
            int m = int.Parse(line_nm[1]);

            for (int i = 0; i < m; i++)
            {
                string[] edgeProp = input_unparsed[linePointer].Split(" ");
                // System.Console.WriteLine($"Edges {string.Join(", ", edgeProp)}");
                // System.Console.WriteLine($"Options {string.Join(", ", edges)}");
                linePointer++;

                string u = edgeProp[0];
                string v = edgeProp[1];

                int temperature = edgeProp[2] == "ohniva" ? 1 : -1;

                graph.AddEdge(u, v);
                System.Console.WriteLine($"Added an edge {u}->{v}");
                // graph.AddEdge(v, u);
                string identificator = i.ToString();

                var key = (u, v);
                var keyBack = (v, u);
                if (edges.ContainsKey(key))
                {
                    int[] temperatures = edges[key].temps;
                    string identificators = edges[key].idents;

                    List<int> tempsList = temperatures.ToList();
                    tempsList.Add(temperature);
                    identificators += identificator;

                    temperatures = tempsList.ToArray();

                    // System.Console.WriteLine($"Added edge option {string.Join(",", temperatures)} - {identificators}");
                    edges[key] = (temperatures, identificators);
                }
                else
                {
                    edges.Add(key, (new int[1] { temperature }, identificator));
                    // System.Console.WriteLine($"Added edge option {string.Join(",", temperature)} - {identificator}");

                }
            }
            // System.Console.WriteLine($"Edges: ");
            // foreach (var key in edges.Keys)
            // {
            //     System.Console.WriteLine($"{string.Join(", ", edges[key])}");
            //     foreach (var s in edges[key].temps)
            //     {
            //         System.Console.WriteLine($"idents {s}");
            //     }
            // }

            string endNode = (n - 1).ToString();
            List<Path> resultPaths = graph.BFSAllShortestPaths("0", endNode, edges);
            // Console.WriteLine($"All shortest paths from 0 to {endNode}:");

            foreach (var path in resultPaths)
            {
                if (path.reachedDes) Console.WriteLine(string.Join(" -> ", path.visited) + " temp: " + path.temperature + " options: " + string.Join(", ", path.options));
                else System.Console.WriteLine("ajajaj");
            }
        }

    }


}
